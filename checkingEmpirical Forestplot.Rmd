---
title: "Investigating the variability for empirical Forest plots"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

## Background 

The uncertainty estimation in empirical Forest plots are dependent only on the uncertainty estimates in the parameters of the model, both typical individual parameters as well as any coefficients of correlated covariates.

Presently the PMXForest package evaluate all parameter vectors on the observed data, meaning that there is no data variability in the predicted covariate effects outside the impact of the estimated parameters. This means that the situation is different between empirical Forest plot predictions for covariates that have parameters in the model compared to covariates for which no coefficients are estimated. Imagine the case of a completely uncorrelated covariate that is not part of the model, the only variability affecting the prediction will be the uncertainty in the typical individual parameters. Since the covariate is not in the model due to non-significance the uncertainty in the predicted effect should larger than significant covariaates, not smaller as it will be in this case. If the covariate is not in the model but is correlated to a covariate that is, then the uncertainty ought to be inveriley related to the correlation betwee the covariates. (a correlation of 0 should mean a larger uncertainty than a significant covariate, a correlation of 1 should mean the same uncertainty as the included and significant covariate).

If a covariate that is not in the model is correlated to a covariate in the model with a fixed coefficient, the only uncertainty affecting the prediction of the first covariate will be the uncertainty in the typical parameter, similar to the situation with a completely uncorrelated covariate.

This must mean that the predictions should be computed based in the bootstrapped data set and not the observed data set:

- A completely uncorrelated covariate will have a randomly assigned TVpar -> large uncertainty
- 

This may mean that the variability in the predicted covariate effects are too small. In case

However, since the data variability affects the parameter estimates, it may be claimed that accounting for the data variability also in the prediction of the covariate effects means that it is accounted for twice.

## Checking the impact of the data used for evaluating the covariate effects 

There are three possibilities:

1. Use the bootstrapped parameter estimates to compute TVV based on the original data and let the limits be defined by the observed data. 
2. Use the bootstrapped parameter estimates to compute TVV based on the bootstrapped data and let the limits be defined by the observed data. 
    - This would work (technically) for continuous covariates but not for categorical covariates.
    - May therefore be inconsistent.
3. Use the bootstrapped parameter estimates to compute TVV based on the original data and let the limits be defined by the bootstrapped data. 

### The observed data

Read in the observed data and exclude records that are ignored in the model.

```{r}
modDir   <- "SimVal"
dataFile <- system.file("extdata",paste0(modDir,"/DAT-1-MI-PMX-2.csv"),package="PMXForest")
dfData   <- read.csv(dataFile) %>% 
  filter(ID   != 895) %>% 
  filter(BLQ  != 1) %>% 
  filter(TYPE != 2) %>% 
  distinct(ID,.keep_all=TRUE) 

nrow(dfData)
```

```{r}
q10 <- function(x) {quantile(x,p=0.1)}
q90 <- function(x) {quantile(x,p=0.9)}
```


## Estimating the WT coefficients for both CL and V

This model estimats the WT coefficients for both CL and V. This is different from the true model in which CL and V were simulated using allometric connstants (0.75 and 1).

### Input from the model

```{r}
wtRunno         <- 9
nIter           <- 25
modDevDir       <- "/PMX/Projects/Pharmetheus/PMX-REP-PMX-2/Analysis/Model/SimVal/EmpTest/"
simtabWTfile    <- file.path(modDevDir, paste0("simtab",wtRunno))
simtabWT        <- read.table(simtabWTfile, header = F)
names(simtabWT) <- c("REP", "ID", "TVCL", "TVV", "THV", "THCL", "THVWT", "THCLWT", "WT", "HT", "BMI", "CRCL",
                     "SEX","AST","WTLOV","WTUPV","WTLOCL","WTUPCL")

nrow(simtabWT)/nIter
```

### Checking the impact of the data used for evaluating the covariate effects 

#### Using the observed data with the limits from the observed data set

This example use the bootstrapped parameter estimates to compute TV parameters based on the **observed data**. The limits are defined by the **observed data**. 

```{r}
## Create a version of the observed data that is repolicated nIter times
dfDataLong        <- dfData[rep(rep(1:nrow(dfData),nIter)),]
dfDataLong$REP    <- rep(1:nIter,each=nrow(dfData))
dfDataLong$THV    <- simtabWT$THV
dfDataLong$THVWT  <- simtabWT$THVWT
dfDataLong$THCL   <- simtabWT$THCL
dfDataLong$THCLWT <- simtabWT$THCLWT

dfDataLong %>% 
  select(ID,REP,THV,THVWT,THCL,THCLWT,WT) %>% 
  mutate(myTVV = THV*(WT/83.9)^THVWT) %>%  
  mutate(myTVCL = THCL*(WT/83.9)^THCLWT) %>% 
  group_by(REP) %>% 
  filter(WT<=q10(dfData$WT) | WT>=q90(dfData$WT)) %>% 
  mutate(side = ifelse(WT<=q10(dfData$WT),"Lo","Hi")) %>%
  pivot_longer(starts_with("myT"),names_to = "Parameter") %>% 
  group_by(Parameter,REP,side) %>% 
  summarise(Median=median(value)) %>% 
  group_by(Parameter,side) %>% 
  summarise(Mean=mean(Median),SD=sd(Median),RSE=SD/Mean)
```

#### Using each bootstrap sample with the limits from the observed data set

This example use the bootstrapped parameter estimates to compute TV parameters on the **bootstrapped data**. The limits are defined by the **observed data**. 
```{r}
simtabWT %>% 
  mutate(myTVV  = THV*(WT/83.9)^THVWT) %>% 
  mutate(myTVCL = THCL*(WT/83.9)^THCLWT) %>% 
  select(REP,myTVV,myTVCL,WT) %>% 
  group_by(REP) %>% 
  filter(WT<=q10(dfData$WT) | WT>=q90(dfData$WT)) %>% 
  mutate(side = ifelse(WT<=q10(dfData$WT),"Lo","Hi")) %>% 
  pivot_longer(starts_with("myT"),names_to = "Parameter") %>% 
  group_by(Parameter,REP,side) %>% 
  summarise(Median=median(value)) %>% 
  group_by(Parameter,side) %>% 
  summarise(Mean=mean(Median),SD=sd(Median),RSE=SD/Mean)

```

#### Using each bootstrap sample with limits defined per sample

This example use the bootstrapped parameter estimates to compute TV parameters on the **bootstrapped data**. The limits are defined by the **bootstrapped data**. 
```{r}
simtabWT %>% 
  mutate(myTVV  = THV*(WT/83.9)^THVWT) %>% 
  mutate(myTVCL = THCL*(WT/83.9)^THCLWT) %>% 
  select(REP,myTVV,myTVCL,WT) %>% 
  group_by(REP) %>% 
  filter(WT<=q10(WT) | WT>=q90(WT)) %>% 
  mutate(side = ifelse(WT<=q10(WT),"Lo","Hi")) %>% 
  pivot_longer(starts_with("myT"),names_to = "Parameter") %>% 
  group_by(Parameter,REP,side) %>% 
  summarise(Median=median(value)) %>% 
  group_by(Parameter,side) %>% 
  summarise(Mean=mean(Median),SD=sd(Median),RSE=SD/Mean)

```

#### Conclusion

* Using the bootstrap estimates to compute the TV-parameters based on the observed data or on the bootstrapped data, with limits from the observed data, generates equivalent results, both in terms of point estimates in the limits as well as in the RSEs. 
* Defining the limits based on the bootstrap samples leads to differences in the point estimates in the limits and somewhat larger RSEs (but still very close).

**The limits should be defined based on the observed data but it doesn't matter if the TV-parameters are derived from the observed or bootstrapped data.**

### Comparing to the parametric results

The model prediction for the impact of WT on CL and V is the reference for the empirical results above.

```{r}

simtabWT %>%
  distinct(REP,.keep_all = TRUE) %>% 
  select(REP,starts_with("WT")) %>% 
  group_by(REP) %>% 
  pivot_longer(WTLOV:WTUPCL,names_to = "Parameter") %>% 
  group_by(Parameter,REP) %>% 
  summarise(Median=median(value)) %>% 
  group_by(Parameter) %>% 
  summarise(Mean=mean(Median),SD=sd(Median),RSE=SD/Mean) 

```

#### Conclusion

There is a good agreement between the empirical and parametric results.


## Checking the performance when a false but correlated covariate is used to compute the empirical results

### Compute the emprical results for HT based on a model in which WT was the predictor

This example use the bootstrapped parameter estimates to compute TV- parameters based on the **bootstrapped data**. The limits are defined by the **observed data**. 
```{r}

simtabWT %>% 
  mutate(myTVV  = THV*(WT/83.9)^THVWT) %>% 
  mutate(myTVCL = THCL*(WT/83.9)^THCLWT) %>% 
  select(REP,myTVV,myTVCL,HT) %>% 
  group_by(REP) %>% 
  filter(HT<=q10(dfData$HT) | HT>=q90(dfData$HT)) %>% 
  mutate(side = ifelse(HT<=q10(dfData$HT),"Lo","Hi")) %>% 
  pivot_longer(starts_with("myT"),names_to = "Parameter") %>% 
  group_by(Parameter,REP,side) %>% 
  summarise(Median=median(value)) %>% 
  group_by(Parameter,side) %>% 
  summarise(Mean=mean(Median),SD=sd(Median),RSE=SD/Mean)
```

### Compute the parameteric results from a model in which HT is the predictor for V

```{r}
htRunno         <- 10
nIter           <- 25
modDevDir       <- "/PMX/Projects/Pharmetheus/PMX-REP-PMX-2/Analysis/Model/SimVal/EmpTest/"
simtabHTfile    <- file.path(modDevDir, paste0("simtab",htRunno))
simtabHT        <- read.table(simtabHTfile, header = F)
names(simtabHT) <- c("REP", "ID", "TVCL", "TVV", "THV", "THCL","THVHT", "THCLWT", "WT", "HT", "BMI", "CRCL","SEX","AST", "HTLOV", "HTUPV")

nrow(simtabWT)/nIter
```

```{r}
simtabHT %>%
  distinct(REP,.keep_all = TRUE) %>% 
  select(REP,starts_with("HT")) %>% 
  group_by(REP) %>% 
  pivot_longer(HTLOV:HTUPV,names_to = "Parameter") %>% 
  group_by(Parameter,REP) %>% 
  summarise(Median=median(value)) %>% 
  group_by(Parameter) %>% 
  summarise(Mean=mean(Median),SD=sd(Median),RSE=SD/Mean) 
```


## Checking the performance when a false and uncorrelated covariate is used to compute the empirical results

Will use AST. Correlation ~0.06 to WT.

```{r}
dfData %>% select(WT,AST) %>% cor(.)
```

```{r}
simtabWT %>% 
  mutate(myTVV  = THV*(WT/83.9)^THVWT) %>% 
  mutate(myTVCL = THCL*(WT/83.9)^THCLWT) %>% 
  select(REP,myTVV,myTVCL,AST) %>% 
  group_by(REP) %>% 
  filter(AST<=q10(dfData$AST) | AST>=q90(dfData$AST)) %>% 
  mutate(side = ifelse(AST<=q10(dfData$AST),"Lo","Hi")) %>% 
  pivot_longer(starts_with("myT"),names_to = "Parameter") %>% 
  group_by(Parameter,REP,side) %>% 
  summarise(Median=median(value)) %>% 
  group_by(Parameter,side) %>% 
  summarise(Mean=mean(Median),SD=sd(Median),RSE=SD/Mean)
```

#### Conclusion

The point estimates are much closer to the mid-point. The RSE is the same as with the true parameter and not a lot larger as would have been desired.

## Checking the performance when a false and categrical covariate covariate is used to compute the empirical results

Will use SEX. Correlation ~-0.35 to WT.

```{r}
dfData %>% select(WT,SEX) %>% cor(.)
```

```{r}
simtabWT %>% 
  mutate(myTVV  = THV*(WT/83.9)^THVWT) %>% 
  mutate(myTVCL = THCL*(WT/83.9)^THCLWT) %>% 
  select(REP,myTVV,myTVCL,SEX) %>% 
  group_by(REP) %>% 
  mutate(side = ifelse(SEX==1,"Male","Female")) %>% 
  pivot_longer(starts_with("myT"),names_to = "Parameter") %>% 
  group_by(Parameter,REP,side) %>% 
  summarise(Median=median(value)) %>% 
  group_by(Parameter,side) %>% 
  summarise(Mean=mean(Median),SD=sd(Median),RSE=SD/Mean)
```

### Using each bootstrap sample with the limits from the original data set

This example use the bootstrapped parameter estimates to compute TVV based on the original data. The limits are defined by the observed data. 

```{r}
dfDataLongHT       <- dfData[rep(rep(1:nrow(dfData),nIter)),]
dfDataLongHT$REP   <- rep(1:nIter,each=nrow(dfData))
dfDataLongHT$THV   <- simtabHT$THV
dfDataLongHT$THVWT <- simtabHT$THVHT


dfDataLongHT %>% 
  mutate(myTVV = THV*(HT/169)^THVWT) %>%  
  group_by(REP) %>% 
  filter(HT<=q10(dfData$HT) | HT>=q90(dfData$HT)) %>% 
  mutate(side = ifelse(HT<=q10(dfData$HT),"Lo","Hi")) %>% 
  group_by(REP,side) %>% 
  summarise(Median=median(myTVV)) %>% 
  group_by(side) %>% 
  summarise(Mean=mean(Median),SD=sd(Median),RSE=SD/Mean)
```

### Using each bootstrap sample with the limits from the original data set

This example use the bootstrapped parameter estimates to compute TVV based on the bootstrapped data. The limits are defined by the observed data. 
```{r}
simtabHT %>% 
  mutate(myTVV = THV*(HT/169)^THVHT) %>% 
  group_by(REP) %>% 
  filter(HT<=q10(dfData$HT) | HT>=q90(dfData$HT)) %>% 
  mutate(side = ifelse(HT<=q10(HT),"Lo","Hi")) %>% 
  group_by(REP,side) %>% 
  summarise(Median=median(myTVV)) %>% 
  group_by(side) %>% 
  summarise(Mean=mean(Median),SD=sd(Median),RSE=SD/Mean)
```

### Using each bootstrap sample with limits defined per sample

This example use the bootstrapped parameter estimates to compute TVV based on the bootstrapped data. The limits are defined by the bootstrapped data. 
```{r}
simtabHT %>% 
  mutate(myTVV = THV*(HT/169)^THVHT) %>% 
  group_by(REP) %>% 
  filter(HT<=q10(HT) | HT>=q90(HT)) %>% 
  mutate(side = ifelse(HT<=q10(HT),"Lo","Hi")) %>% 
  group_by(REP,side) %>% 
  summarise(Median=median(myTVV)) %>% 
  group_by(side) %>% 
  summarise(Mean=mean(Median),SD=sd(Median),RSE=SD/Mean)

```

## Comparing with parametric calculations of HT

With V it is possible to estimate an effect of HT and therefore also derive the limits parametrically. This is done in NONMEM partially and the target HT are set to the 5th and 95th percentile.

```{r}
simtabHT %>% 
  mutate(myTVV = THV*(HT/169)^THVHT) %>% 
  group_by(REP) %>% 
  summarise(MedLo = median(THV*HTLO), MedMid = median(THV*HTMID),MedUp = median(THV*HTUP)) %>% 
  ungroup %>% 
  summarise(Lo = mean(MedLo),Up = mean(MedUp), SDLo = sd(MedLo),SDUp = sd(MedUp),RSELo=SDLo/Lo,RSEUp = SDUp/Up)
```

