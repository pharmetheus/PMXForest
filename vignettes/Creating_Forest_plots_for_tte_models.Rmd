---
title: "Creating Forest plots for tte models"
output: 
  bookdown::html_document2:
    toc: true
vignette: >
  %\VignetteIndexEntry{Creating_Forest_plots_for_scm_and_scmplus_models}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

<!-- output: rmarkdown::html_vignette -->

```{r setup,}
suppressPackageStartupMessages(library(PMXForest))
library(tools)

theme_set(theme_bw(base_size=18))
theme_update(plot.title = element_text(hjust = 0.5))

set.seed(865765)
```

# Introduction


This vingette goes through the steps of creating a Forest plots using a Time-To-Event (TTE) model. In principle, the idea is similar to a Forest plot using any other type of data/model but in this particular case the Forest plot illustrates Hazard Ratios, assuming that the covariate effects in the TTE model has been added as proportional hazards to the base model, i.e $h_0(t) \cdot e^(COV1+COV2...)$

In this example, the forest plot will be of the SCM parametric type and the uncertianty will come from either a bootstrap sample or sampling from a covariance matrix.


## Creating parametric Forest plots from scmplus models

Overall, there are three sets of required specifications needed:

1. The covariate values of interest needs to be specified (Section \@ref(sec:dfCovs)).
2. The model for the primary and/or secondary parameters need to be implemented in R functions (Section \@ref(sec:paramFunction)).
3. The multivariate distribution of the primary parameters needs to be derived (Section \@ref(sec:multivariateDist)).

With these specifications the data for the Forest plot can be setup (using the function `getForestDFSCM`, see Section \@ref(sec:setUpDataPar)) and the Forest plot created (see Section \@ref(sec:createForest)).


### Define the covariates to include in the Forest plot {#sec:dfCovs}

This specification has one required and two optional components.

The required specification is the list of covariate values to predict the parameter for. It is created using a helper function (`createInputForestData`)
```{r}
dfCovs <- createInputForestData(
  list( "AGE" = c(35,50,65),
        "EXP" = c(0,100,200,300,400,500)),
  iMiss=-99) 
```

The data.frame `dfCovs` specifies the covariate values, or combination of values to visualize in the Forest plot. Each line if `dfCovs` correspond to one "row" in the Forest plot.
```{r, echo=F}
dfCovs
```

The structure of the `dfCovs` list determines how the covariate values are grouped on the y-axis. For example, the structure above would group `FORM` 0 an 1, `FOOD` 0 and , etc, and the groups will be slightly separated from each other in the plot.

The `cdfCovsNames` argument to `getForestDFSCM` is optional and specifies a name to be used for each row in `dfCovs`. If not provided, the original covariate names (e.g. `AGE`and `EXP`) will be used on the y-axis in the Forest plot.
```{r}
covnames <- c("Age 35 y","Age 50 y","Age 65 y","Placebo","Drug conc of 100 ng/mL","Drug conc of 200 ng/mL","Drug conc of 300 ng/mL","Drug conc of 400 ng/mL","Drug conc of 500 ng/mL")
```

The reference subject will be a subject with and Age of 50 year in the Placebo group.

```{r}
dfRefRow <- data.frame("AGE"=50,"EXP"=0)
```


### Define the model function {#sec:paramFunction}

The `functionList` argument to `getForestDFSCM` is a list of functions that computes the parameters to plot in the Forest plot from the NONMEM parameter estimates. More than one function can be provided but only the case with one function is covered in this document.

It is worth pointing out that this is a fragile part of the process of creating Forest plots with the `PMXForest` package. The user needs to specify the function to derive the parameter of interest, not seldom duplicating code already specified in NONMEM. Please be careful.

The most general approach is to (re-)define the NONMEM model for the typical individual parameters. The function below defines the models for CL, FREL and V, but only CL is returned in this case. 

This function will be called once for each row in `dfCovs` and each parameter set in the `dfSamples*` data frames (see below), and for `dfRefRow`, and it will use the available covariate columns and the values in those columns. This means that we need to handle the case when a covariate is not be present in `dfCovs` as well as the -99s. Note that there will be -99s in `dfCovs` even if there are no missing covariate values in the NONMEM data set. If the NONMEM code doesn't handle -99s, the code in the function here needs to be adjusted.

The parameter functions will have to accept a vector of fixed effects parameter estimates (`thetas`) and a one row data frame with covariate values. Other arguments provided by the user to `getForestDFSCM` will also be passed to the parameter functions.

Here is a general procedure for implementing the NONMEM code in the R function:

1. Copy the relevant parts of the NONMEM model file to the function.
2. Translate the NONMEM code to R:
    a. Replace NONMEM's `THETA()` with R's `theta[]`.
    b. Replace NONMEM's `EQ` (etc) with the corresponding R equivalent.
    c. Other modifications as needed, e.g `LOG` -> `log`
3. Make sure that the code handles missing covariate values (-99). * Note! This is needed even if the original NONMEM code didn't do this.*
4. Make sure that the code handles the case when the input data.frame (`df`) does not include columns for all covariates in the model. (See the `any(names(df))` below.)
  

```{r}

paramFunction <- function(thetas, df, ...) {
  
  lambda <- thetas[1]
  shape  <- thetas[2]
  
  RF<-0
  
  if(any(names(df) == "AGE") && df$AGE!=-99) {
    RF<-RF+(df$AGE/50)**thetas[3]
  }

  EFF<-0
  if(any(names(df) == "EXP") && df$EXP!=-99) {
    EFF<-thetas[4]*df$EXP
  }

  #Hazard ratio of all covariates effects
  HR<-exp(RF+EFF)
  
  return(HR)
}


```
We also need to provide a name for the output from the function.

```{r}
functionListName <- c("Hazard Ratio")
```


### Obtain the multivariate distribution of the primary parameters {#sec:multivariateDist}

The `getForestDFSCM` package supports four methods for obtaining the uncertainties in the predicted parameter values (see Section \@ref(sec:uncertainty)). All of them require information from the .ext file.

```{r}
runno   <- "tte_weibull"

extFile <- system.file("extdata","tte",paste0(runno,".ext"),package="PMXForest")
```


#### Use the output from the $COV step in NONMEM

This approach will sample parameter vectors from a variance-covariance matrix from NONMEM.

Read the cov file and get the multivariate parameter distribution.
```{r}
covFile <- system.file("extdata","tte",paste0(runno,".cov"),package="PMXForest") 
dfSamplesCOV <- getSamples(covFile,extFile=extFile,n=200)
```


#### Use the output from a bootstrap

This approach obtain the confidence interval limits non-parametrically from a (n=100) bootstrap. 


```{r}
bootFile    <- system.file("extdata","tte","bootstrap_tte_weibull_n100",paste0("raw_results_",runno,".csv"),package="PMXForest")
dfSamplesBS <- getSamples(bootFile,extFile=extFile)
```

```{r}

root<-"c:/PMX/Projects/Pharmetheus/PMX-REP-PMX-2/Analysis/Model/SimVal/bs22-2.dir"
bootFile <- file.path(root,"extdata","NMParameterTable/bs22-2.dir/raw_results_run22-2bs.csv")
extFile <- file.path(root,"extdata","NMParameterTable/run7.ext")


## Sample from the varcov matrix
set.seed("123")
tmp <- getSamples(bootFile,extFile=extFile)

tmp %>% select(one_of(paste0("THETA",4:7),paste0("OMEGA.",c(1,3:6),".",c(1,3:6),"."),"SIGMA.1.1."))


```


#### Use the output from a SIR analysis

This approach obtain the confidence interval limits non-parametrically from the SIR samples in a SIR analysis. 


```{r,cache=TRUE}
sirFile    <- system.file("extdata","sir_dir1",paste0("raw_results_run",runno,".csv"),package="PMXForest")
dfSamplesSIR <- getSamples(sirFile,extFile=extFile)
```



### Set up the data for the Forest plot {#sec:setUpDataPar}

The actual data to be plotted is assembled by the `getForestDFSCM` function. In addition to the information assembled above one additional argument is required - the number of fixed effects in the NONMEM model (`noBaseThetas`).

First we create a convenience function to save space later on.

```{r}
  dfres <- getForestDFSCM(dfCovs = dfCovs,
                          cdfCovsNames = covnames,
                          functionList = list(paramFunction),
                          functionListName = functionListName,
                          noBaseThetas = 4,
                          dfParameters = dfSamplesBS, 
                          dfRefRow = dfRefRow,
                          cstrPackages = c("dplyr"))

```


### Create the Forest plot {#sec:createForest}

The Forest plots below displays the data on a relative scale, with the reference being defined in the `dfRefRow` data.frame. Included are also dashed vertical lines at 0.8 and 1.25 to visualize a(n imagined) region of clinical irrelevance. The plotForestDF function returns a ggplot object so additions like this can easily be made.
```{r ForestCOV,fig.width=12,fig.asp=0.6,out.width="100%"}
plotForestDF(dfres,log10x = TRUE)+
  geom_vline(xintercept=c(0.8,1.25),linetype="dashed") +
  ggtitle("Based on $COV")

```

```{r ForestBSmsall,fig.width=12,fig.asp=0.6,out.width="100%"}
plotForestDF(dfresBSsmall)+
  geom_vline(xintercept=c(0.8,1.25),linetype="dashed") +
  ggtitle("Based on a varcov matrix from a small bootstrap")
```

```{r ForestBS,fig.width=12,fig.asp=0.6,out.width="100%"}
plotForestDF(dfresBS)+
  geom_vline(xintercept=c(0.8,1.25),linetype="dashed") +
  ggtitle("Based a large bootstrap")
```


```{r ForestSIR,fig.width=12,fig.asp=0.6,out.width="100%"}
plotForestDF(dfresSIR)+
  geom_vline(xintercept=c(0.8,1.25),linetype="dashed") +
  ggtitle("Based on a SIR analysis")
```



# Empirical Forest plots
Empirical Forest plots derive the predicted covariate effects based on the multivariate covariate distribution in the current data set. The difference to what is referred to as parametric predictions in this document is that the empirical predictions are taken as summary measures of the predicted typical individual parameter estimates from the model and observed covariates. Parametric predictions, in contrast, are derived directly from the fixed effects parameter estimates of the model and specific covariate values of interest. 

For example, a parametric prediction of CL for a typical subject would be the predicted CL from the model obtained when setting all covariates to their typical value. The corresponding empirical estimate would be obtained as the median of all individual CL values predicted using the available individual covariate values (and setting any random effects on CL to 0). Similarly, for SEX, the parametric estimate of CL would be the model predictions of CL obtained by setting the SEX covariate to either male or female while the empirical predictions would be the median of the male and female individual estimates of CL predicted using the available individual covariate values (and setting any random effects on CL to 0). 
For continuous covariates, for example body weight, the parametric prediction would be obtained by setting the covariate to values at the tails of the covariate distribution (e.g. 40kg and 140kg). The empirical predictions would be obtained by computing the median of the individual estimates of CL for the groups of subjects with values of the covariate of interest lower and higher than defined extreme values, for example the 5th and 95th percentiles in the data set.

With the above in mind it is obvious that empirical Forest plots rely on an observed multivariate covariate distribution while parametric Fores plots can use any covariate value regardless of if it is included in the observed data range or not. It is also clear that empirical Forest plots can visualize the impact of all available covariates regardless of if they are included in the model or not (in the above example it is not necessary that the model includes SEX, the predicted individual CL values can still be split by SEX). Parametric Forest plots would by default predict no impact of covariates not included in the model.



## Creating empirical Forest plots {#sec:empForest}

The procedure for generating the information for empirical Forest plots follows the same general procedure as parametric Forest plots:

1. The covariate values of interest needs to be specified (Section \@ref(sec:dfCovsEmp)).
2. The model for the primary and/or secondary parameters need to be implemented in R functions (Section \@ref(sec:paramFunctionEmp)).
3. The multivariate distribution of the primary parameters needs to be derived (Section \@ref(sec:multivariateDistEmp)).

With these specifications the data for the Forest plot can be setup (using the function `getForestDFemp`, see Section \@ref(sec:setUpDataEmp)) and the Forest plot created (see Section \@ref(sec:createForestEmp)).


### Define the covariates to include in the Forest plot {#sec:dfCovsEmp}

This is done differently for empirical Forest plots than for parametric Forest plots. In the parametric situation discrete covariate values are specified. For empirical Forest plots it is necessary to provide an expression that defines the covariate range for the subjects whose typical individual parameter estimates should be taken the median of. An example is provided below. It loosely corresponds to the parametric example above. 

```{r}
lsExpr<-rev(list(expression(SEX==2),
                 expression(SEX==1),
                 expression(CRCL>=146),
                 expression(CRCL<94),
                 expression(AGE>=57),
                 expression(AGE<35),
                 expression(WT>104),
                 expression(WT<70),
                 expression(RACEL==3),
                 expression(RACEL==2),
                 expression(RACEL==1),
                 expression(GENO==4),
                 expression(GENO==3),
                 expression(GENO==2),
                 expression(GENO==1),
                 expression(FOOD==1),
                 expression(FOOD==0),
                 expression(FORM==1),
                 expression(FORM==0)))
```

Only "univariate" conditions are included in the above expression list but it is easy to see how combination conditions can be set up (e.g. `expression(SEX==1 & WT>100)`) but keep in mind that these expressions create subsets of the observed data set, the more conditions that are combined, the smaller the subgroup. With smaller data sets small subgroups will rapidly become an issue, even with only one condition in the expression.

The list `lsExpr` specifies the covariate values, or combination of values to visualize in the Forest plot. Each line if `lsExpr` correspond to one "row" in the Forest plot.
```{r, echo=F}
lsExpr
```

`lsExpr` is provided as the argument `covExpressionList` to `getForestDFemp` (see Section \@ref(sec:setUpDataEmp)). Other related arguments, e.g. `cdfCovsNames`, `cGrouping` and `dfRefRow` are equivalent to the parametric counterparts (see Section \@ref(sec:dfCovs)) and are setup similarly:

```{r}

# cGroupingEmp = c(1,1,2,2,3,3,3,3,4,4,4,5,5,6,6,7,7,8,8,9,9) # This will not be needed for the examples below.

covnamesEmp <- c("Oral tablets","FDC","Fasted","Fed","2D6 UM","2D6 EM","2D6 IM","2D6 PM","Caucasian","African American","Asian and other","WT<70 kg","WT>104 kg",
                 "Age<35 y","Age>57 y","CRCL<94 mL/min","CRCL>146 mL/min","Male","Female")
```



### Define the model function {#sec:paramFunctionEmp}

The model function specification is the same for empirical as for parametric Forest plots (see Section \@ref(sec:paramFunction). 

For empirical Forest plots, this function will be called once for each subject in the data set (vectorized) row in `dfCovs` and each parameter set in the `dfSamples` data frames (see below). It is also called once per subject for `dfRefRow` (but this makes less sense for empirical Forest plots. NEED TO EXPLAIN THIS BETTER.)

### Obtain the multivariate distribution of the primary parameters {#sec:multivariateDistEmp}

This step occurs before the empirical and parametric Forest plots procedures diverge so the multivariate parameter distributions are derived in the same manner as for the parametric Forest plots (see Section \@ref(sec:multivariateDist)). 

### Set up the data for the Forest plot {#sec:setUpDataEmp}

The actual data to be plotted is assembled by the `getForestDFemp` function. This is a different function than what is used for the parametric Forest plots (`getForestDFSCM`) although the arguments overlap. 

One argument that is common to the two functions but that is more relevant to the empirical Forest plots is the `ncores` argument. A value of `ncores`great than 1 signals to the `getForestDF*`functions that the calls to the model function should be done in a parallel fashion. The reason that this is more relevant to empirical Forest plots is that they typically involves longer computations. However, it can also be useful also for parametric Forest plots when the uncertainty is derived using SIR. For parallel computations it may be necessary to provide the `cstrPackages` and `cstrExports` arguments.

First we create a convenience function to save space later on.

```{r}
getPlotDataEmp <- function(dfSamples,dfRefRow=NULL) {
  
  dfres <- getForestDFemp(
    dfData             = dfData,
    covExpressionsList = lsExpr,
    cdfCovsNames       = covnamesEmp,
    functionList       = list(paramFunction),
    functionListName   = functionListName,
    noBaseThetas       = 16,
    dfParameters       = dfSamples, 
    dfRefRow           = dfRefRow,
    ncores             = 6
  )
  
  return(dfres)
}

```

In contrast to parametric Forest plots, empirical Forest plots require the data file (or rather a file with the covariates in the covariate model plus and other covariates of interest). Only the first row per subject is used.

```{r}
# The system.file gives access to the exampel files distributed with the package.
dataFile <- system.file("extdata","DAT-1-MI-PMX-2.csv",package="PMXForest")
dfData   <- read.csv(dataFile) %>% distinct(ID,.keep_all=TRUE)
```

Compute the data to be plotted based on the \$COV step:
```{r COVplotDataEmp, cache=TRUE}
dfresCOVemp     <- getPlotDataEmp(dfSamplesCOV,dfRefRow = dfRefRow)
```

Compute the data to be plotted based on a small bootstrap:
```{r BSsmallplotDataEmp, cache=TRUE}

dfresBSsmallemp <- getPlotDataEmp(dfSamplesBSsmall,dfRefRow = dfRefRow)
```

Compute the data to be plotted based on a large bootstrap:
```{r BSplotDataEmp, cache=TRUE}

dfresBSemp <- getPlotDataEmp(dfSamplesBS,dfRefRow = dfRefRow)
```

Compute the data to be plotted based on a SIR analysis:
```{r SIRplotDataEmp,cache=TRUE}
dfresSIRemp <- getPlotDataEmp(dfSamplesSIR,dfRefRow = dfRefRow)
```

### Create the empirical Forest plot {#sec:createForestEmp}

The reference line in these plots corresponds to the median typical individual prediction of CL.

```{r,fig.width=12,fig.asp=0.6,out.width="100%", cache=TRUE}
 plotForestDF(dfresCOVemp)+
   xlim(0,3.3) +
   geom_vline(xintercept=c(0.8,1.25),linetype="dashed") +
  ggtitle("Based on $COV")
```

```{r,fig.width=12,fig.asp=0.6,out.width="100%", cache=TRUE}
 plotForestDF(dfresBSsmallemp )+
   xlim(0,3.3) +
   geom_vline(xintercept=c(0.8,1.25),linetype="dashed") +
  ggtitle("Based on a varcov matrix from a small bootstrap")
```

```{r,fig.width=12,fig.asp=0.6,out.width="100%", cache=TRUE}
 plotForestDF(dfresBSemp )+
   xlim(0,3.3) +
   geom_vline(xintercept=c(0.8,1.25),linetype="dashed") +
  ggtitle("Based a large bootstrap")
```

```{r,fig.width=12,fig.asp=0.6,out.width="100%", cache=TRUE}
 plotForestDF(dfresSIRemp)+
   xlim(0,3.3) +
   geom_vline(xintercept=c(0.8,1.25),linetype="dashed") +
  ggtitle("Based on a SIR analysis")
```

# The reference {#sec:referenceValues}
